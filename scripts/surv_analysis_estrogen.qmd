# Estrogen receptor status is continuous, not dichotomous

Currently in the clinics estrogen receptor (ER) status is treated 
as dichotomous condition. Either a breast cancer (BC) is ER positive (ER+) or
ER negative (ER-). The threshold for ER+ cells usually is 1% or 10% of the 
cells positive in a IHC staining. The idea is that ER+ BC patients
will receive endocrine therapy, usually tamoxifen or some aromatase inhibitor,
for treatment. The problem is not all patients respond the same to these
drugs and they also have different proportions of ER+ cells. 

In this document we show how leveraging molecular information distinguishes
ER+ BC patients and how one should look more carefully on ER status. In order
to do this, estrogen related signatures: estrogen response early and late from
MSigDB[@Subramanian2005] and $SET_{ER/PR}$[@Sinn2019], 
are used to calculate scores for each
BC patient. These scores then are used to calculate associations with survival
analysis. When performing cox regression, we try to adjust for sensible 
covariates in order to reduce bias. Even though we are adjusting, it is 
very difficult to know if a covariate is missing in the regression. Thus,
care should be always taken when interpreting these results.

This chapter is structure in the following way. First section corresponds
to loading the datasets and then filtering them. Estrogen signatures scores
are calculated using GSVA [@Hnzelmann2013]. Given the scores, cox regression
can be performed adjusting for clinical variables. After this the Hazard
ratios can be computed and interpreted along with their confidence
intervals.

## Loading and filtering the datasets

The preprocessing of the datasets is described in the website below:
> https://chronchi.github.io/transcriptomics

To check the code used here either click in the code button on the top right
part of the page or check the github page 
(github.com/chronchi/molecular_landscape).

The TCGA, METABRIC and SCANB cohorts are used in this section here. They
are the biggest cohort of Breast cancer patients in the world. Each datasets
has an overall equal distribution of ER+ and ER- patients and similar age
distribution. 

```{r setup}
# init renv due to docker installation
renv::restore()

# first load the packages
library(tidyverse)

library(ggplot2)
library(forestplot)
library(ggplotify)
library(gridExtra)

library(SummarizedExperiment)
library(survival)
library(msigdbr)
library(GSVA)
library(uwot)

source("utils.R")
source("first_run.R")

# by setting the dev to png and pdf, this saves the figures in a specific
# folder in both formats. moreover, since png is coming first, it shows
# this figure when rendering the html. What is nice about this is that it
# inherits the properties from the chunk to save the figure, so no need
# to use ggplot2::ggsave to save the plots. this also works 
knitr::opts_chunk$set(dev = c('png', 'pdf', 'svg'))
```

```{r, eval = first_run}
# load the different datasets. we will do the analysis 
# and save the intermediate results so loading all the dataset again
# is not necessary
tcga <- readRDS("../data/tcga_brca_tumor_filtered.rds")
metabric <- readRDS("../data/metabric_filtered.rds")
scanb <- readRDS("../data/scanb.rds")

# we want to have common variables across datasets. so for tcga
# we convert the ensembl ids to gene symbol in the rownames,
# for scanb and metabric we perform a heavier filtering as well.
# also for the clinical data we want to have common column names,
# such as for pam50, events, time to event, tumor stage,
# tumor grade and others.

# first convert ensembl to symbol. this information is readily available
# from the tcga filtered data. we just need to remove duplicated symbols
# first.
symbol_names <- mcols(rowRanges(tcga)) %>% 
    data.frame %>% 
    dplyr::filter(!duplicated(external_gene_name))

tcga <- tcga[symbol_names$ensembl_gene_id, ]
rownames(tcga) <- symbol_names$external_gene_name

fpkm_tcga <- 2^assay(tcga, "logFPKM_TMM")
prop_expressed <- rowMeans(fpkm_tcga > 1)
genes_to_keep <- prop_expressed > 0.5
tcga <- tcga[genes_to_keep, ]

# we now filter down the list of genes from metabric and scanb.

# remove first genes with na in the table
keep_genes <- rowMeans(assay(metabric, "median_intensity") > 5.5)
keep_genes <- keep_genes > 0.7 %>% unname %>% unlist
keep_genes <- which(is.na(keep_genes))
metabric <- metabric[-keep_genes, ]
# now remove genes with low expression across samples
keep_genes <- rowMeans(assay(metabric, "median_intensity") > 5.5)
keep_genes <- keep_genes > 0.7
metabric <- metabric[keep_genes, ]

# convert back to non log values and then filter.
fpkm_scanb <- 2^assay(scanb, "logFPKM")
prop_expressed <- rowMeans(fpkm_scanb > 1)
genes_to_keep <- prop_expressed > 0.8
scanb <- scanb[genes_to_keep, ]

# we now convert the clinical data to some common names and values
tcga <- tcga[, tcga$er_status %in% c("Positive", "Negative")]
tcga$er_status <- c("Positive" = "pos", "Negative" = "neg")[tcga$er_status]
tcga$pam50 <- tolower(tcga$molecular_subtype)
tcga$os_days <- tcga$time
tcga$os_months <- tcga$os_days/30
tcga$os_status <- tcga$status
tcga$tumor_stage <- tolower(tcga$paper_pathologic_stage)
tcga$age <- tcga$age_at_index
tcga$sample_name <- colnames(tcga)
node_stage <- tcga$ajcc_pathologic_n
tcga$node_stage <- ifelse(
    grepl("^N0", node_stage),
    "N0",
    ifelse(
        grepl("^N1", node_stage),
        "N1",
        ifelse(
            grepl("^N2", node_stage),
            "N2",
            ifelse(
                grepl("^N3", node_stage),
                "N3",
                "NX"
            ) 
        )
    )
)

metabric <- metabric[, metabric$ER_IHC %in% c("Positve", "Negative")]
metabric$er_status <- c("Positve" = "pos", "Negative" = "neg")[metabric$ER_IHC]
metabric$pam50 <- tolower(metabric$CLAUDIN_SUBTYPE)
metabric$os_months <- metabric$OS_MONTHS
metabric$rfs_months <- metabric$RFS_MONTHS
metabric$os_status <- substr(metabric$OS_STATUS, 1, 1) %>% as.numeric
metabric$os_status <- metabric$os_status + 1
metabric$rfs_status <- substr(metabric$RFS_STATUS, 1, 1) %>% as.numeric
metabric$rfs_status <- metabric$rfs_status + 1
metabric$age <- metabric$AGE_AT_DIAGNOSIS
metabric$npi <- metabric$NPI 
metabric$NPI <- NULL
metabric$sample_name <- colnames(metabric)

scanb <- scanb[, scanb$ER_1perc %in% c("NEG", "POS")]
scanb$er_status <- tolower(scanb$ER_1perc)
scanb$pam50 <- tolower(scanb$PAM50)
scanb$PAM50 <- NULL
scanb$nhg <- scanb$NHG
scanb$NHG <- NULL
scanb$age <- scanb$Age
scanb$os_months <- scanb$OS_months
scanb$os_status <- scanb$OS_event + 1
scanb$tumor_size <- scanb$TumorSize
scanb$tumor_stage <- scanb$TStage
scanb$node_group <- scanb$Node_group
scanb$Node_group <- NULL
scanb$sample_name <- colnames(scanb)
node_stage <- scanb$node_group
scanb$node_stage <- ifelse(
    grepl("1to3", node_stage),
    "N1",
    ifelse(
        grepl("4toX", node_stage),
        "N2and3",
        ifelse(
            grepl("NodeNegative", node_stage),
            "N0",
            "NX"
        )
    )
)
    
saveRDS(
    list(tcga = tcga, scanb = scanb, metabric = metabric),
    "../results/rds_files/surv_analysis_estrogen/datasets.rds"
)

which_exp <- list(
    tcga = "logFPKM_TMM",
    scanb = "logFPKM",
    metabric = "median_intensity"
)

saveRDS(
    which_exp,
    "../results/rds_files/surv_analysis_estrogen/which_exp.rds"
)
```

```{r}
datasets <- readRDS("../results/rds_files/surv_analysis_estrogen/datasets.rds")

# these are some global parameters for each dataset. important for
# when calculating scores and embeddings.
which_exp <- readRDS("../results/rds_files/surv_analysis_estrogen/which_exp.rds")
```

## UMAP projection of the datasets

The plots below show how each patient is different in a molecular sense, 
and even inside each molecular subtype there are some differences. This
indicates how different patients, at least molecularly. We only do the umap
of samples that have a PAM50 molecular subtype assigned.

```{r, eval = first_run}
# first one uses the library uwot to calculate the umap projection.
# using uwot is better than umap as it allows you to make parallel computations
# in a reproducible way.
umap_projections <- mapply(
    function(dataset, name_assay){
        
        cat("Assay being used:", name_assay, "\n")
        
        samples_to_use <- colData(dataset) %>% data.frame %>%
            dplyr::filter(pam50 %in% 
                c("basal", "her2", "luma", "lumb", "normal")
            ) %>% 
            dplyr::pull(sample_name)
        
        # select most variable genes first
        df <- assay(dataset[, samples_to_use], name_assay) %>% as.matrix
        df <- df[order(rowVars(df), decreasing = TRUE)[1:1000], ]
        df <- t(df)
        
        uwot::umap(
            df,
            n_threads = 20,
            n_sgd_threads = "auto", 
            batch = TRUE
        )
    },
    datasets,
    which_exp,
    USE.NAMES = TRUE,
    SIMPLIFY = FALSE
)

saveRDS(
    umap_projections, 
    "../results/rds_files/surv_analysis_estrogen/umap_projections.rds"
)
```

```{r}
umap_projections <- readRDS(
    "../results/rds_files/surv_analysis_estrogen/umap_projections.rds"
)
```

```{r, fig.width=10, fig.height=20}
#| label: fig-surv-umap-all
#| fig-cap: UMAP projections of all three cohorts in the following order":" 
#|     TCGA, SCANB and METABRIC. They are colored by the PAM50
#|     molecular subtype.
plots_umap <- mapply(
    plot_umap,
    sum_exp = datasets,
    umap_projection = umap_projections,
    cohort = names(datasets),
    MoreArgs = list(color_by = "pam50", point_size = 2, base_size = 20),
    USE.NAMES = TRUE,
    SIMPLIFY = FALSE
)

cowplot::plot_grid(plotlist = plots_umap, ncol = 1)
```

```{r, eval = first_run}
width_plot <- 12
height_plot <- width_plot/1.6
dir.create(
    "../results/plots/surv_analysis_estrogen/umap/", 
    showWarnings = FALSE, 
    recursive = TRUE
)

a <- mapply(
    ggsave,
    plot = plots_umap,
    filename = paste0(
        "../results/plots/surv_analysis_estrogen/umap/",
        names(plots_umap),
        ".pdf"
    ),
    MoreArgs = list(width = width_plot, height = height_plot)
)
```

From the plots above we see a distinction of the different molecular subtypes.

## Calculating scores

In order to calculate the scores, the package `msigdb` is used to load
the hallmark data into R. The $SET_{ER/PR}$ is made of the following genes:

```{r}
# data is available in the supplementary material of the paper 
seterpr <- read.table("../data/seterpr.tsv", header = TRUE)
seterpr$is_target <- c(rep("yes", 18), rep("no", 10))
seterpr %>% kableExtra::kbl() %>%
    kableExtra::kable_classic(full_width = FALSE)
```

The first 18 genes are considered to be the target genes, the last 10 genes
are the genes used for reference. According to their paper, the score is 
calculated in the following way:

$$
SET_{ER/PR} = \sum_{i = 1}^{18} \frac{T_i}{18} - \sum_{j=1}^{10}\frac{R_j}{10} + 2
$$

Where $T_i$ are the expression levels of target genes and $R_j$ are the
expression levels of the reference genes. Here we use GSVA to calculate
the scores, even when using their genes. 

```{r, eval = first_run}
all_genes <- sapply(datasets, rownames) %>% unlist %>% unique
# now load the msigdbr and concatenate with set erpr
gene_sets <- msigdbr::msigdbr(species = "Homo sapiens", category = "H") %>% 
    dplyr::select(gs_name, gene_symbol) %>%
    dplyr::bind_rows(
        .,
        seterpr %>% dplyr::filter(is_target == "yes") %>%
            dplyr::select(ID) %>%
            dplyr::rename(gene_symbol = ID) %>%
            dplyr::mutate(gs_name = "SET_ERPR")
    ) %>%
    dplyr::bind_rows(
        .,
        data.frame(gene_symbol = sample(all_genes, 200), gs_name = "random_200")
    ) %>%
    dplyr::bind_rows(
        .,
        data.frame(gene_symbol = sample(all_genes, 18), gs_name = "random_18")
    )

saveRDS(gene_sets, "../results/rds_files/surv_analysis_estrogen/gene_sets.rds")
```

Before we calculate any score, let us check the number of genes available
for each pathway in each dataset. This is important, in other to have
robust scores, most of the genes should be available in the datasets. We also
add signatures of 18 and 200 random genes for control. 

```{r}
gene_sets <- readRDS("../results/rds_files/surv_analysis_estrogen/gene_sets.rds")
```

```{r}
genes_each_dataset <- lapply(datasets, rownames)
genes_intersection <- sapply(
    gene_sets$gs_name %>% unique,
    function(set_name, gene_sets, genes_each_dataset){
        lapply(
            genes_each_dataset,
            intersect,
            y = gene_sets %>% 
                dplyr::filter(gs_name == set_name) %>%
                dplyr::pull(gene_symbol)
        )
    },
    gene_sets = gene_sets,
    genes_each_dataset = genes_each_dataset,
    USE.NAMES = TRUE,
    simplify = FALSE
)

sapply(genes_intersection, function(x) sapply(x, length)) %>% t %>%
    data.frame %>%
    tibble::rownames_to_column(var = "pathway") %>%
    dplyr::inner_join(
        .,
        gene_sets %>% 
            dplyr::group_by(gs_name) %>%
            dplyr::summarise(n = n()) %>%
            dplyr::rename(pathway = gs_name),
        by = "pathway"
    ) %>% 
    dplyr::rowwise() %>%
    dplyr::mutate(average_percentage = format(mean(
            c(tcga/n, scanb/n, metabric/n)
        ),
        digits = 2
    )) %>% 
    kableExtra::kbl() %>%
    kableExtra::kable_classic(full_width = FALSE)
```

Most of the genes are available in all datasets. When calculating scores
it is always good to check the availability of the genes. Otherwise this
can make the score unstable, since too many of the genes are missing. 
For example, 
HALLMARK_PANCREAS_BETA_CELLS might have an unstable score, due to a lot 
of genes missing. 

```{r, eval = first_run}
which_exp <- list(
    tcga = "logFPKM_TMM",
    scanb = "logFPKM",
    metabric = "median_intensity"
)

gene_sets <- sapply(
    gene_sets$gs_name %>% unique,
    function(x, gene_sets) gene_sets %>% dplyr::filter(gs_name == x) %>% 
        dplyr::pull(gene_symbol),
    gene_sets = gene_sets,
    USE.NAMES = TRUE,
    simplify = FALSE
)

gsva_scores <- mapply(
    function(sum_exp, which_assay, gene_sets){
        GSVA::gsva(
            expr = as.matrix(assay(sum_exp, which_assay)),
            gset.idx.list = gene_sets, 
            parallel.sz = 20
        )
    },
    sum_exp = datasets,
    which_assay = which_exp,
    MoreArgs = list(gene_sets = gene_sets),
    SIMPLIFY = FALSE,
    USE.NAMES = TRUE
)

saveRDS(
    gsva_scores, 
    "../results/rds_files/surv_analysis_estrogen/gsva_scores.rds"
)
```

```{r}
gsva_scores <- readRDS(
    "../results/rds_files/surv_analysis_estrogen/gsva_scores.rds"
)

datasets <- mapply(
    function(gsva_score, dataset){
        colData(dataset)[, rownames(gsva_score)] <- t(gsva_score)
        dataset
    },
    gsva_scores,
    datasets,
    USE.NAMES = TRUE,
    SIMPLIFY = FALSE
)

saveRDS(
    datasets,
    "../results/rds_files/surv_analysis_estrogen/datasets_with_scores.rds"
)
```

```{r}
gsva_scores <- readRDS(
    "../results/rds_files/surv_analysis_estrogen/gsva_scores.rds"
)

datasets <- readRDS(
    "../results/rds_files/surv_analysis_estrogen/datasets_with_scores.rds"
)
```


For each dataset one can plot the differences in scores for ER+ and ER- BC
patients. This should be already an indication that the scores are meaningful.
The next sections shows the results for each dataset individually.

```{r}
plot_scores <- list()
which_scores <- c(
    "HALLMARK_ESTROGEN_RESPONSE_EARLY",
    "HALLMARK_ESTROGEN_RESPONSE_LATE",
    "SET_ERPR",
    "random_200",
    "random_18"
)
```

::: {.panel-tabset}

### TCGA

```{r}
which_dataset <- "tcga"
plot_scores[[which_dataset]] <- mapply(
    plot_scores_vs_clinics,
    which_score = which_scores,
    title = which_scores,
    MoreArgs = list(
        sum_exp = datasets[[which_dataset]],
        clinical_variable = "er_status", 
        color_by = "pam50",
        base_size = 10,
        point_size = 0.5
    ),
    USE.NAMES = TRUE,
    SIMPLIFY = FALSE
)
```

```{r, fig.width=10, fig.height=8}
#| label: fig-scores-tcga
#| fig-cap: Scores for TCGA patients
cowplot::plot_grid(plotlist = plot_scores[[which_dataset]], ncol = 2)
```

### METABRIC

```{r}
which_dataset <- "metabric"
plot_scores[[which_dataset]] <- mapply(
    plot_scores_vs_clinics,
    which_score = which_scores,
    title = which_scores,
    MoreArgs = list(
        sum_exp = datasets[[which_dataset]],
        clinical_variable = "er_status", 
        color_by = "pam50",
        base_size = 10,
        point_size = 0.5
    ),
    USE.NAMES = TRUE,
    SIMPLIFY = FALSE
)
```

```{r, fig.width=10, fig.height=8}
#| label: fig-scores-metabric
#| fig-cap: Scores for METABRIC patients
cowplot::plot_grid(plotlist = plot_scores[[which_dataset]], ncol = 2)
```

### SCANB

```{r}
which_dataset <- "scanb"
plot_scores[[which_dataset]] <- mapply(
    plot_scores_vs_clinics,
    which_score = which_scores,
    title = which_scores,
    MoreArgs = list(
        sum_exp = datasets[[which_dataset]],
        clinical_variable = "er_status", 
        color_by = "pam50",
        base_size = 10,
        point_size = 0.5
    ),
    USE.NAMES = TRUE,
    SIMPLIFY = FALSE
)
```

```{r, fig.width=10, fig.height=8}
#| label: fig-scores-scanb
#| fig-cap: Scores for SCANB patients
cowplot::plot_grid(plotlist = plot_scores[[which_dataset]], ncol = 2)
```

:::

From the plots above one can conclude that three different estrogen pathways
capture the differences between ER status and also molecular subtypes.
There are two plots with random genes for control and we can see that
there is no difference between the ER status when using those gene sets.

Below is a combined image for TCGA, SCANB and METABRIC using the $SET_{ER/PR}$
signature.

```{r, fig.height=10, fig.width = 6}
#| label: fig-scores-metabric-tcga-scanb
#| fig-cap: SET ER/PR scores for all three cohorts.
pathway_to_get <- c("SET_ERPR" = "SET ER/PR")
seterpr_plots <- purrr::map(plot_scores, names(pathway_to_get)[1])
seterpr_plots <- seterpr_plots[c("tcga", "scanb", "metabric")]
seterpr_plots <- mapply(
    function(plot, cohort, pathway){
        plot + 
            ggplot2::labs(
                title = paste0(toupper(cohort), " - ", pathway)
            )
    },
    plot = seterpr_plots,
    cohort = names(seterpr_plots),
    MoreArgs = list(pathway = pathway_to_get[1]),
    SIMPLIFY = FALSE,
    USE.NAMES = TRUE
)

cowplot::plot_grid(plotlist = seterpr_plots, ncol = 1)
```


Another way to look at the data is to plot by molecular subtype instead
of ER status.

::: {.panel-tabset}

### TCGA

```{r}
clinical_variable <- "pam50"
color_by <- "er_status"
```


```{r}
which_dataset <- "tcga"
plot_scores[[which_dataset]] <- mapply(
    plot_scores_vs_clinics,
    which_score = which_scores,
    title = which_scores,
    MoreArgs = list(
        sum_exp = datasets[[which_dataset]],
        clinical_variable = clinical_variable, 
        color_by = color_by,
        base_size = 10,
        point_size = 0.5
    ),
    USE.NAMES = TRUE,
    SIMPLIFY = FALSE
)
```

```{r, fig.width=10, fig.height=8}
#| label: fig-scores-tcga-pam50
#| fig-cap: Scores for TCGA patients stratified by PAM50 molecular subtype
cowplot::plot_grid(plotlist = plot_scores[[which_dataset]], ncol = 2)
```

### METABRIC

```{r}
which_dataset <- "metabric"
plot_scores[[which_dataset]] <- mapply(
    plot_scores_vs_clinics,
    which_score = which_scores,
    title = which_scores,
    MoreArgs = list(
        sum_exp = datasets[[which_dataset]],
        clinical_variable = clinical_variable, 
        color_by = color_by,
        base_size = 10,
        point_size = 0.5
    ),
    USE.NAMES = TRUE,
    SIMPLIFY = FALSE
)
```

```{r, fig.width=10, fig.height=8}
#| label: fig-scores-metabric-pam50
#| fig-cap: Scores for METABRIC patients stratified by PAM50 molecular subtype
cowplot::plot_grid(plotlist = plot_scores[[which_dataset]], ncol = 2)
```

### SCANB

```{r}
which_dataset <- "scanb"
plot_scores[[which_dataset]] <- mapply(
    plot_scores_vs_clinics,
    which_score = which_scores,
    title = which_scores,
    MoreArgs = list(
        sum_exp = datasets[[which_dataset]],
        clinical_variable = clinical_variable, 
        color_by = color_by,
        base_size = 10,
        point_size = 0.5
    ),
    USE.NAMES = TRUE,
    SIMPLIFY = FALSE
)
```

```{r, fig.width=10, fig.height=8}
#| label: fig-scores-scanb-pam50
#| fig-cap: Scores for SCANB patients stratified by PAM50 molecular subtype
cowplot::plot_grid(plotlist = plot_scores[[which_dataset]], ncol = 2)
```

:::

In all cohorts the luminal A and B patients have a similar score. Also
the distinction is very clear between the basal and HER2-like patients
versus luminal A and B.

One question that usually arises when calculating scores from gene sets is
if proliferation associated genes (PAG) are driving the distinctions. 
These signatures are highly curated and they have close or no PAGs. 
Therefore, the scores are not affected by PAGs and they really reflect the
biology.

In the next section we will show how these scores are also prognostic for
ER+ BC patients.


## Survival analysis

Since the scores are continuous variables and they are already scaled due
to the output of GSVA, cox regression [@Cox1972] can be used. The advantages 
of using cox regression is that one can control for other variables. You might
ask, why should one control for clinical variables? One of the reasons is 
because the data being dealt here is observational data. There are several
confounders, for example, a score might be up because patients with a higher
tumor grade have higher expression of some genes. Thus the score is confounded
by the tumor grade and the interpretation changes. 

There are limitations still when dealing with observational data. A strong 
hypothesis for performing survival analysis with observational data is that
we have measured all the confounder variables. This is pretty strong and in
practice we never know if a confounder is missing or not. For a more
thorough overview of the causal framework for observational data, check
the books [@Gelman2020-uh; @McElreath2020-jn].

All the cohorts have a different set of clinical variables available. Therefore,
the regression will be done by adjusting a different set of variables. Below
is the description of the variables used for each cohort.^[This [webpage](https://web.archive.org/web/20220630083539/https://www.cancer.net/cancer-types/breast-cancer/stages) explains with more details the different tumor stages and how
BC are classified.]

- **Age**: age is one of the most important factors to adjust, specially in
breast cancer. This covariate is used for all cohorts.
- **NPI**: the Nottingham prognostic index scores each tumor
based on tumor grade, tumor size and number of lymph nodes. Only METABRIC
has this information. 
- **Tumor Size**: as name describes. Only SCANB has this information. 
- **Tumor Stage**: tumors are usually described in terms of stage, it reflects
the tumor size and location. SCANB and TCGA have this information.
- **Node Stage**: similar to tumor stage, but encodes the number of lymph nodes
where breast cancer cells can be found. SCANB and TCGA have this information.

Thus the models we are going to use for the survival analysis of each dataset
is shown below.

- TCGA: `~ score + age + node_stage + tumor_stage`,
- SCANB: `~ score + age + node_stage + tumor_stage`,
- METABRIC: `~ score + age + NPI`,

where score is one of the scores calculated earlier with GSVA. Note here
that since each node stage and tumor stage have sub classifications they 
will be grouped together, otherwise there will be too many variables with
few points. We will also subselect specific tumor stages for TCGA and SCANB,
since there are very few patients with tumor stage 4.

To be very specific in the survival analysis, only endocrine treated patients
should be used in the analysis, as that is what are interested in. METABRIC
and SCANB has this kind of annotation, but TCGA not. So the survival analysis
on SCANB and METABRIC will be performed on endocrine only treated, ER+ BC
patients. On TCGA, to mitigate this effect, we subselect only luminal A and 
B patients, and we keep in mind that they might have been treated with
chemotherapy as well. Moreover, in Sweden the guidelines for BC treatment is to
use 10% as the threshold for ER status. Therefore, ER+ BC patients used on
SCANB are those that are above the 10% threshold.

The table below shows the number of patients for each cohort.

```{r}
tcga_samples <- colData(datasets$tcga) %>% data.frame %>%
    dplyr::filter(
        pam50 %in% c("luma", "lumb") &
        node_stage != "NX" &
        !(tumor_stage %in% c("stage_iv", "na")) & 
        er_status == "pos"
    ) %>% 
    dplyr::pull(sample_name)

scanb_samples <- colData(datasets$scanb) %>% data.frame %>%
    dplyr::filter(
        node_stage != "NX" &
        !(tumor_stage %in% c("T4", "Tis", "TX")) & 
        ER_10perc == "POS" & 
        Adjuvant_Endo_only == 1
    ) %>% 
    dplyr::pull(sample_name)

metabric_samples <- colData(datasets$metabric) %>% data.frame %>%
    dplyr::filter(
        CHEMOTHERAPY == "NO" &
        er_status == "pos" & 
        HORMONE_THERAPY == "YES"
    ) %>% 
    dplyr::pull(sample_name)

data.frame(
    cohort = c("TCGA", "SCANB", "METABRIC"),
    number_patients = c(
        length(tcga_samples),
        length(scanb_samples),
        length(metabric_samples)
    ),
    nb_events = c(
        datasets$tcga %>% colData %>% data.frame %>%
            dplyr::filter(sample_name %in% tcga_samples & os_status == 2) %>%
            dplyr::summarise(n = n()) %>%
            dplyr::pull(n),
       datasets$scanb %>% colData %>% data.frame %>%
            dplyr::filter(sample_name %in% scanb_samples & os_status == 2) %>%
            dplyr::summarise(n = n()) %>%
            dplyr::pull(n),
       datasets$metabric %>% colData %>% data.frame %>%
            dplyr::filter(sample_name %in% metabric_samples & os_status == 2) %>%
            dplyr::summarise(n = n()) %>%
            dplyr::pull(n)
    )
) %>% kableExtra::kbl() %>%
    kableExtra::kable_classic(full_width = FALSE)
```

```{r, eval = first_run}
# run the survival analysis for each dataset with its own formula.
# we start by defining the base formulas, because later we sapply and 
# add the scores. this way if we need to change the formulas, we only
# need to change once and all together.
formulas_survival <- c(
    "os_tcga" = "Surv(os_months, os_status) ~ age + node_stage + tumor_stage",
    "os_scanb" = "Surv(os_months, os_status) ~ age + node_stage + tumor_stage",
    "os_metabric" = "Surv(os_months, os_status) ~ age + npi",
    "rfs_metabric" = "Surv(rfs_months, os_status) ~ age + npi"
)

type_survival <- c("os", "rfs")
which_scores <- c(
    "HALLMARK_ESTROGEN_RESPONSE_EARLY",
    "HALLMARK_ESTROGEN_RESPONSE_LATE",
    "SET_ERPR",
    "random_200",
    "random_18"
)
survival_results <- sapply(
    c("os", "rfs"),
    function(type_analysis, datasets, name_scores, formulas){
        mapply(
            function(
                dataset, name_dataset, name_scores, formulas, type_analysis
            ){
                
                if (type_analysis == "rfs" & name_dataset != "metabric"){
                    return()
                } else { 
                
                    sapply(
                        name_scores,
                        function(name_score, col_data, formula){
                            
                            survival::coxph(
                                as.formula(
                                    paste(formula, name_score, sep = "+")
                                ),
                                data = col_data, 
                                y = FALSE,
                                x = FALSE
                            )
                        },
                        col_data = colData(dataset) %>% data.frame,
                        formula = formulas[
                            grepl(
                                paste(type_analysis, name_dataset, sep = "_"),
                                names(formulas)
                            )
                        ],
                        USE.NAMES = TRUE,
                        simplify = FALSE
                    )
                }
            },
            dataset = datasets,
            name_dataset = names(datasets),
            MoreArgs = list(
                formulas = formulas, name_scores = name_scores,
                type_analysis = type_analysis
            ),
            USE.NAMES = TRUE,
            SIMPLIFY = FALSE
        )
    },
    datasets = mapply(
        function(dataset, patients) dataset[, patients],
        dataset = datasets,
        patients = list(tcga_samples, scanb_samples, metabric_samples),
        USE.NAMES = TRUE,
        SIMPLIFY = FALSE
    ),
    name_scores = which_scores,
    formulas = formulas_survival,
    USE.NAMES = TRUE,
    simplify = FALSE
)

survival_results$rfs <- survival_results$rfs[
    !sapply(survival_results$rfs, is.null)
]

# we cannot simply save the models as each model has some 
# environment variables, which adds up to over 20GB. 
# check this stack exchange thread to read more on it:
# https://stackoverflow.com/questions/42230920/saverds-inflating-size-of-object/52372480
# the solution is to basically clear the environment from the terms 
# object. since it is pretty fast to run the survival analysis
# we will not save the objects.


# we now proceed to prepare the plots. since the survival result is 
# actually a large file, it is best to do all the plottings, save
# them in other rds/pdf files and then use on the quarto markdown.
# otherwise it is too slow to render the book. 
# the same is true for the statistics and coefficients available.
names_signatures <- c(
    "HALLMARK_ESTROGEN_RESPONSE_EARLY" = "Estrogen Early",
    "HALLMARK_ESTROGEN_RESPONSE_LATE" = "Estrogen Late",
    "SET_ERPR" = "SET ER/PR",
    "random_200" = "random 200 genes",
    "random_18" = "random 18 genes"
)

names_coefficients <- list(
    metabric = c(
        "age" = "Age", 
        "npi" = "NPI", 
        names_signatures
    ),
    scanb = c(
        "age" = "age",
        names_signatures,
        "node_stageN1" = "N1",
        "node_stageN2and3" = "N2 and N3",
        "tumor_stageT1" = "T1",
        "tumor_stageT2" = "T2",
        "tumor_stageT3" = "T3"
    ),
    tcga = c(
        "age" = "age",
        "tumor_stage" = "Tumor Stage",
        names_signatures,
        "node_stageN1" = "N1",
        "node_stageN2" = "N2",
        "node_stageN3" = "N3",
        "tumor_stagestage_ii" = "T2",
        "tumor_stagestage_iii" = "T3"
    )
)

patients <- list(
    tcga = "Lum A/B, ER+ BC",
    scanb = "Endo Only, ER+ BC",
    metabric = "Endo Only, ER+ BC"
)

dir.create(
    paste0(
        "../results/plots/surv_analysis_estrogen/forest_plots/",
        c("pdf", "png")
    ), 
    showWarnings = FALSE, 
    recursive = TRUE
)

forest_plots <- mapply(
    function(fits, type_analysis){
        mapply(
            function(cohort_fits, name_cohort, type_analysis){
                mapply(
                    forest_plot_fits,
                    fit = cohort_fits,
                    name_signature = names(cohort_fits),
                    MoreArgs = list(
                        cohort = name_cohort,
                        names_coefficients = names_coefficients,
                        type_survival = toupper(type_analysis),
                        patients = patients[[name_cohort]],
                        #clip = c(0.1, 2),
                        width = 6.5, 
                        height = 3, 
                        path_to_save = paste0(
                            "../results/plots/surv_analysis_estrogen",
                            "/forest_plots/"  
                        ) 
                    ),
                    USE.NAMES = TRUE,
                    SIMPLIFY = FALSE
                )
            
            },
            cohort_fits = fits,
            name_cohort = names(fits),
            MoreArgs = list(type_analysis = type_analysis),
            USE.NAMES = TRUE,
            SIMPLIFY = FALSE
        )
    },
    survival_results,
    names(survival_results),
    USE.NAMES = TRUE,
    SIMPLIFY = FALSE
)

# all forest plots are saved as a pdf in the 
# results/plots/surv_analysis_estrogen folder and
# as a rds file in the folder below.

saveRDS(
    forest_plots,
    "../results/rds_files/surv_analysis_estrogen/forest_plots.rds"
)

# and now we fetch the tables that will be used later on including the
# confidence intervals and other parameters from the fit
tables_survival <- lapply(
    survival_results, 
    function(x) 
        lapply(
            x,
            function(y)
                lapply(
                    y,
                    function(z) broom::tidy(z)
                ) %>% dplyr::bind_rows(.id = "score")
        ) %>% dplyr::bind_rows(.id = "cohort")
) %>% dplyr::bind_rows(.id = "type_analysis") %>%
    dplyr::mutate(HR = exp(estimate))

write.csv(
    tables_survival,
    "../results/tables/surv_analysis_estrogen/survival_results.csv",
    row.names = FALSE
)
```

```{r}
tables_survival <- read.csv(
    "../results/tables/surv_analysis_estrogen/survival_results.csv"
)

forest_plots <- readRDS(
    "../results/rds_files/surv_analysis_estrogen/forest_plots.rds"
)
```

### Results

The table below shows the results for each analysis performed for a specific
term. In order to understand the table the user can filter based on the term,
cohort and type of analysis. Since METABRIC has recurrence free survival (RFS)
and overall survival (OS), the results for both analysis are presented here. 

```{r}
tables_survival %>% 
    DT::datatable(options = list(scrollX = TRUE), filter = 'top') %>% 
    DT::formatRound(
        columns=c(
            "estimate", "std.error", "statistic", "HR"
        ), 
        digits = 2
    ) %>% 
    DT::formatSignif(columns = c("p.value"))
```

The table above shows that $SET_{ER/PR}$ had a small hazard ratio (< 1) in all
4 analysis performed. Moreover, for all cases where a measure of estrogen
signaling was used, the hazard ratio was below 1, indicating that the higher
the score, the less likely the patient is to suffer the event in a specific
timepoint. This indicates that ER signaling is actually something continuous
and not dichotomous.

@fig-forest-plot shows the forest plot of $SET_{ER/PR}$ for all 
three cohorts. 

```{r, fig.height=10, fig.width = 7}
#| label: fig-forest-plot
#| fig-cap: Forest plots of the different cohorts and their hazard ratios.
#|     The bars correspond to 95% confidence interval.

# we use the workaround described here:
# https://stackoverflow.com/questions/71266791/combine-several-forestplot-object-in-one-graph-in-r
# we convert the forest plots to grob and then used gridExtra to 
# plot into the output
which_pathway <- "SET_ERPR"
plots_seterpr <- lapply(
    forest_plots$os, 
    function(x){
        ggplotify::grid2grob(print(x[[which_pathway]]))
    } 
)

gridExtra::grid.arrange(
    plots_seterpr$tcga, 
    plots_seterpr$scanb,
    plots_seterpr$metabric
)
```

The hazard ratios are all below 1 and small for $SET_{ER/PR}$.
The variability changes depending on the cohort, 
specially because they have different follow-up times, 
SCANB being the shortest. TCGA has very few events, but using the 10
to 1 rule of thumb, 
meaning 10 events for each covariate added, the regression
satisfies the rule of thumb.

## Conclusion

In this chapter we've shown that ER+ BC patients are very distinct
from each other, as it can be seen from the umap projections and 
the subtypes. These patients might respond differently for endocrine therapy
as well, and this might depend on the ER signaling, how active it is. 
Therefore, when deciding a treatment, more care should be taken with
ER+ BC patients and check their signaling scores somehow. The $SET_{ER/PR}$
signature is a good signature showing very good hazard ratios across
the different cohorts. This signature has also been validated on the clinics
for use.

Knowing the ER signaling for a patient is very important when deciding
treatment, but not enough. What could be other alternatives for patients
that have low ER signaling and are still considered ER+? Should they use
only endocrine therapy or supplement it with something else? In the
next chapters we present a framework where we can take a look
at a more personalised approach for treatments. 

