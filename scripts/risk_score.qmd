# Risk score model

Several risk signatures were developed over the years using transcriptomic
datasets. Some examples were given in the previous chapters, such as 
OncotypeDX, Prosigna and EndoPredict. They were all derived in a similar
manner, subsetting genes related to usually estrogen and proliferation 
signaling and then using recurrence free survival data to calculate
the risk scores. 

In this chapter we introduce a new risk score that does not subset
genes and uses the information of the molecular landscape. The concept
is simple, we will use the third and fourth components as covariates in
the survival modeling along with tumor size and node status. This
way we avoid subsetting and selecting specific genes and we use all
the information the molecular landscape is providing us. Also it avoids
any kind of binning for patients based on molecular subtype, thus not being
necessary calculating correlations with pre-defined molecular subtypes.

```{r}
renv::restore()

library(tidyverse)

library(ggplot2)
library(PCAtools)

library(singscore)
library(SummarizedExperiment)
library(survival)

source("utils.R")
source("first_run.R")

# the following script load all data necessary to run the chunks.
# the data is generated from this quarto document itself, therefore
# if you are running this documents the first time and don't have the
# files, comment the following lines. Moreover, if this is your first
# time running the document, you should run all chunks, to generate 
# all the necessary files, if you don't have them. Once all files 
# are saved and available in the respective folder, the following
# lines can be executed. 
if (first_run){
    load_at_setup <- FALSE
} else {
    load_at_setup <- TRUE
}

name_document <- "risk_score"
source("load_rds_files.R")

# by setting the dev to png and pdf, this saves the figures in a specific
# folder in both formats. moreover, since png is coming first, it shows
# this figure when rendering the html. What is nice about this is that it
# inherits the properties from the chunk to save the figure, so no need
# to use ggplot2::ggsave to save the plots. this also works 
knitr::opts_chunk$set(dev = c('png', 'pdf', 'svg'))
options(bitmapType = 'cairo')
```


We develop a risk score for early stage breast cancer patients that 
received only endocrine therapy (ET). The idea is similar to what was
done with the EndoPredict signatures, but here we extend it by using the
molecular landscape information. This provides a full framework where
we can analyse the risk of recurrence even for patients that have 
high ER+ percentage.

## Generating the risk score

We focus only on the endocrine treated patients. For the training part
of the algorithm we use a subset of patients from the METABRIC cohort.
We then test the risk scores in the test set and we further validate
the score on SCANB. 

We will generate two risk scores: one including only the principal 
components and another one including the clinical features of the 
patients when valiable, namely tumor size, node status and age (either having
one or more lymph node with breast cancer cells or none). 

```{r}
# start by preparing the datasets so it is easily used later
df_pca_metabric <- df_pca %>% 
    dplyr::filter(cohort == "metabric") %>%
    dplyr::mutate(TreatGroup = dplyr::case_when(
        HORMONE_THERAPY == "YES" & CHEMOTHERAPY == "YES" ~ "ChemoEndo",
        HORMONE_THERAPY == "YES" & CHEMOTHERAPY == "NO" ~ "Endo",
        TRUE ~ "Other"
    )) %>% 
    dplyr::mutate(node_status = ifelse(
        LYMPH_NODES_EXAMINED_POSITIVE > 0, 
        "pos",
        "neg"
    )) %>% 
    dplyr::mutate(
        node_status = factor(node_status, levels = c("neg", "pos")),
        tumor_size = TUMOR_SIZE
    )

df_pca_scanb <- df_pca %>% 
    dplyr::filter(cohort == "scanb") %>%
    dplyr::mutate(node_status = ifelse(
        node_group == "N0", 
        "neg",
        "pos"
    )) %>% 
    dplyr::mutate(node_status = factor(
        node_status, levels = c("neg", "pos")
    ))

# select only the endocrine treated patients
endo_only_scanb <- df_pca_scanb %>% 
    dplyr::filter(
            TreatGroup == "Endo" & 
            !is.na(rfs_status) & 
            !is.na(rfs_months) &
            er_status == "pos" &
            !is.na(age) &
            !is.na(tumor_size) &
            !is.na(node_status)
    )

endo_only_metabric <- df_pca_metabric %>% 
    dplyr::filter(
            HORMONE_THERAPY == "YES" & 
            CHEMOTHERAPY == "NO" &
            !is.na(rfs_status) & 
            !is.na(rfs_months) &
            er_status == "pos" &
            !is.na(age) &
            !is.na(tumor_size) &
            !is.na(node_status)
    )

# set the seed so we can reproduce the results later and then
# select the training cohort
set.seed(12938)
training_set <- endo_only_metabric %>%
    dplyr::slice_sample(prop = 0.6)

# we use the two PCs we have been investigating, but that does not mean
# other PCs can't be used
pcs_to_use <- paste0("PC", c(3:4))
clin_vars <- c("tumor_size", "node_status", "age")

risk_score_model <- survival::coxph(
    as.formula(paste0(
        "Surv(time = rfs_months, event = rfs_status) ~ ",
        paste(c(pcs_to_use, clin_vars), collapse = "+")
    )),
    data = training_set
)

saveRDS(
    risk_score_model,
    "../results/risk_score/risk_score_model.rds"
)
```

```{r}
summary(risk_score_model)
```

We see that all coefficients have less variability than age. We still keep
all the variables when calculating the risk score, since age has a coefficient
relatively small we can keep it. 

Now we calculate only the risk score based on the components. 

```{r}
risk_score_model_pcs <- survival::coxph(
    as.formula(paste0(
        "Surv(time = rfs_months, event = rfs_status) ~ ",
        paste(c(pcs_to_use), collapse = "+")
    )),
    data = training_set
)

risk_score_model_clins <- survival::coxph(
    as.formula(paste0(
        "Surv(time = rfs_months, event = rfs_status) ~ ",
        paste(c(clin_vars), collapse = "+")
    )),
    data = training_set
)

saveRDS(
    risk_score_model_pcs,
    "../results/risk_score/risk_score_model_pcs.rds"
)
```


```{r}
summary(risk_score_model_pcs)
```

We see that the coefficients are very similar to what was found before,
it didn't change much. Also when we include the principal components on the
top of the clinical variables the log likelihood increases, which is 
a good indication: 

```{r}
anova(risk_score_model_clins, risk_score_model)
```

```{r}
# first get the coefficients 
coefs_risk_model <- coef(risk_score_model)
coefs_risk_model_pcs <- coef(risk_score_model_pcs)

# let us save them so they can be used later as well
saveRDS(
    coefs_risk_model,
    "../results/risk_score/coefs_risk_model.rds"
)
saveRDS(
    coefs_risk_model_pcs,
    "../results/risk_score/coefs_risk_model_pcs.rds"
)

# now we can calculate the scores for all the patients. For TCGA and POETIC
# we do not have tumor size, so for those we calculate the risk score based
# on the components only.
endo_only_scanb$risk_score <- calculate_risk_score(coefs_risk_model, endo_only_scanb)
endo_only_metabric$risk_score <- calculate_risk_score(coefs_risk_model, endo_only_metabric)

df_pca_metabric$risk_score <- calculate_risk_score(coefs_risk_model, df_pca_metabric) 
df_pca_scanb$risk_score <- calculate_risk_score(coefs_risk_model, df_pca_scanb)

# we can now calculate the score for all samples based on PC3 and PC4
df_pca$risk_score_pcs <- calculate_risk_score(coefs_risk_model_pcs, df_pca, is_node = FALSE)

test_set <- endo_only_metabric %>%
    dplyr::filter(!(sample_name %in% training_set$sample_name))

risk_score_test <- survival::coxph(
    Surv(time = rfs_months, event = rfs_status) ~ risk_score,
    data = test_set
)

risk_score_test_clins <- survival::coxph(
    Surv(time = rfs_months, event = rfs_status) ~ risk_score + 
        tumor_size,
    data = test_set
)
```

Now we use the test set to calculate the score.

```{r}
summary(risk_score_test)
```

We see that the higher the risk score the worse it is for the patients 
treated only with endocrine therapy. 

## Validating the risk score on SCANB

We can now validate the risk score on the SCANB dataset. 

```{r}
risk_score_scanb <- survival::coxph(
    as.formula(paste0(
        "Surv(time = rfs_months, event = rfs_status) ~ ",
        paste(c("risk_score"), collapse = "+")
    )),
    data = endo_only_scanb
)

summary(risk_score_scanb)
```

Again the risk score is predictive with a high coefficient, meaning
that the higher the score the worse it is for the patient. 

We now visualize a bit the risk scores developed here in terms 
of the molecular landscape. @fig-risk-endo-pam50

```{r}
#| label: fig-risk-endo-pam50
#| fig-cap: Molecular landscape of SCANB patients treated with only
#|     endocrine therapy and that have ER+ breast cancer. Only patients
#|     with risk score less than 2 are plotted here. There are only 26
#|     patients out of 2829 with risk score higher than 2 that would skew 
#|     the color scale.
endo_only_scanb %>%
    dplyr::filter(risk_score < 2) %>%
    ggplot2::ggplot(aes(x = PC3, y = PC4, color = risk_score)) +
    ggplot2::geom_point() + 
    ggplot2::scale_color_viridis_c() + 
    ggplot2::theme_bw() +
    ggplot2::labs(color = "Risk score") +
    change_plot_aes_point()
```

We now investigate the risk score among patients that have high ER IHC
percentage as well. We have seen that these patients have different outcomes
based on the molecular estrogen signaling. We now investigate the effect
of the risk score. 

```{r}
risk_score_scanb_highER <- survival::coxph(
    as.formula(paste0(
        "Surv(time = rfs_months, event = rfs_status) ~ ",
        paste(c("risk_score"), collapse = "+")
    )),
    data = endo_only_scanb %>%
        dplyr::filter(ER.pct >= 90 & risk_score < 2)
)

summary(risk_score_scanb_highER)
```

We see that the score is still predictive, meaning that even patients
that have high ER IHC percentage, there are those with higher risk. Note
though that the analysis still is a bit limited due to the followup time
that in median is `r format(median(endo_only_scanb$rfs_month)/12, digits = 2)` 
years.

## Risk score and POETIC trial

We can evaluate one of the two risk scores, the one using only the 
principal components, in the POETIC trial data. The first question we
can address is if there is difference in scores in the baseline tissue 
(@fig-poetic-risk-score).

```{r}
#| label: fig-poetic-risk-score
#| fig-cap: Risk scores for responders and non-responders in the baseline
#|     tumor tissue. 
df_pca %>%
    dplyr::filter(
        cohort == "poetic" & 
            timepoint == "baseline" & 
            is_responder != "not_available"
    ) %>%
    ggplot2::ggplot(aes(x = is_responder, y = risk_score_pcs)) +
    ggplot2::geom_violin(alpha = 0.3) + 
    ggplot2::geom_jitter() + 
    ggplot2::labs(
        x = "Response status",
        y = "Risk score (PCs only)",
        title = "Risk score (PCs only) based on response status"
    ) +
    ggplot2::theme_bw(base_size = 20) +
    change_plot_aes_point()
```

We see in the @fig-poetic-risk-score that in average the non responders
have higher risk scores. Now if we compare the risk scores between
baseline and surgery, the slope of the line that fits for each group
separately, responder and non responder, is different. The slope
for the non responders is parallel to the identity line going through
the origin with a slope of 1, meaning that there is not much change of risk
upon the treatment. On other hand, for the responder group the slope is
decreased and has a value lower than 1, meaning that the risk is decreased
upon aromatase inhibition after two weeks (@fig-poetic-risk-base-surgery).

```{r}
#| label: fig-poetic-risk-base-surgery
#| fig-cap: Comparison of risk scores using the PCs only before and after
#|     two weeks of aromatase inhibitors in post-menopausal women. The colored
#|     lines correspond do the linear regression for each response status
#|     group separately. 
df_pca %>%
    dplyr::filter(
        cohort == "poetic" & 
            is_responder != "not_available"
    ) %>%
    tidyr::pivot_wider(
        id_cols = c("patient_nb", "is_responder"),
        names_from = "timepoint",
        values_from = "risk_score_pcs"
    ) %>%
    ggplot2::ggplot(aes(x = baseline, y = surgery, color = is_responder)) +
    ggplot2::geom_point() +
    ggplot2::geom_abline(slope = 1, intercept = 0, linetype = "dashed") + 
    ggplot2::geom_smooth(method = "lm", formula = "y ~ x") +
    ggplot2::labs(
        x = "Baseline risk score",
        y = "Surgery risk score",
        title = "Risk score (PCs only)",
        color = "Is responder?"
    ) +
    ggplot2::theme_bw(base_size = 20) +
    change_plot_aes_point()
```
